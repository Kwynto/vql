# VQL
Это описание обычного языка запросов (VQL) для систем управления базами данных (СУБД).  

**_Этот репозиторий находится на этапе разработки_**  

***Информация:*** 
VQL - это простой императивный язык для работы с базами данных, свободный от излишеств и помогающий создавать простые, понятные и эффективные запросы к СУБД.  

***Ревизия:*** 
VQL-24 0.0.1  


## Список терминов: 
|Термин|Описание|
|:-|:-|
|БД|база данных|
|Таблица|двумерных массив, является организационной единицей и реальным хранилищем информации внутри баз данных|
|Запись|строка двумерного массива (таблицы) в котором храняться данные|
|Ячейка|элемент записи|
|Столбец|совокупность всех ячеек находящихся в одной позиции во всех записях|
|СУБД|система управления базами данных|


## VQL позволяет:

- создавать, удалять и изменять БД и таблицы 
- описывать структуру данных 
- определять данные в БД и управлять ими 
- получать доступ к данным в СУБД 
- устанавливать разрешения на доступ к данным и на манипулирование данными 


## Основные особенности.

- База данных -- это организованная коллекция данных, предназначенная для хранения информации. 
- Коллекции данных можно представлять как двумерные массивы или таблицы. 
- Строка таблицы может называться "запись". 
- Запись состоит из ячеек, которые в контексте таблицы формируют столбцы. 
- Столбцы должны иметь имена и определяют имена для ячеек в записях. 
- Имена БД, таблиц и столбцов (ячеек) должны соответствовать формату `^[a-zA-Z][a-zA-Z0-9_-]*`
- Записи могут иметь дополнительные служебные ячейки, имена которых должны начинатся с символа подчеркивания "_", то есть соответствовать формату  `^_[a-zA-Z0-9_-]+`
- Каждая запись в рамках таблицы должна иметь уникальный идентификатор "_id". 
- Идентификатор записи является уникальным и при удалении записи этот идентификатор не может быть использован повторно для другой записи. 
- Идентификатор записи НЕ является порядковым индексом в таблице. 
- Идентификатор записи может быть сгенерирован криптографическим методом, либо может быть простым инкрементным идентификатором. 
- Ячейки имена которых имеют в своем составе постфикс "_id", являются ячейками для связи таблиц, где левая часть имени (до "_id"), является названием таблицы. 
- Ячейки не имеют типа, так как данные в ячейках это просто набор байт, и данные в ячейкам могут интерпретироваться как строки, которые можно преобразовывать в любой тип на стороне клентского ПО, или в скрипте пользовательского запроса. 
- Результаты выборок данных желательно представлять в формате JSON (для максимальной совместимости с другими языками). 


## Язык запросов 

### Базовые концепции

- Запрос представляет собой сценарий обращений к СУБД (программу) 
- Запрос соистоит из логических блоков, называемых операциями 
- Операция может состоять из одного или нескольких операндов 
- Каждая операция пишется на отдельно строке без конечных символов, либо с разелителем "\n" в конце каждой операции 
- Правильным оформлением запроса является только оформление в соответствии с принципом 1TBS 
- Выполнение запроса
    - Запрос не имеет точки входа и началом выполнения запроса является первая строка запроса 
    - Каждая операция в запросе выполняется последовательно 
    - Объявления и описания пользовательских функций происходит прямо в теле запроса 
    - Функция должна быть объявлена и описана до её вызова 
    - Функция после объявления может быть сохранена в базу данных для повторного использования при помощи дерективы store funcName 
    - Функция может быть удалена из БД дерективой forget funcName 
    - Каждая база данных имеет свой набор сохраненных функций 
    - Если при сохранении новой функции имя функции уже занято, то старая функция удаляется из БД, а новая записывается 
    - Имена функций должны соответствовать шаблону `[a-zA-Z][a-zA-Z0-9_-]+` 
- Блок операций обозначается символами "{" и "}", то есть так обозначается начало и концец блока операций 
    - Блоком операций является тело описания функции 
    - Блоком операций является тело цикла 
    - Блок операций может быть объявлен произвольно в любом месте сценария запроса, формируя анонимную функцию 
        - Анонимная функция может использоватся как правый операнд и возвращать значение дерективой return 
        - Анонимная функция может возвращать значение и записывать результат выполнения в переменную левого операнда, но её внутренний код не может быть присвоин переменной для дальнейшего вызова 
- VQL предполагает использование переменных, которые должны начинаться с символа $ и соответствовать шаблону `\$[a-zA-Z0-9_-]+` 
    - Переменные предназначены для временного хранения данных во время выполнения запроса 
    - Переменные не требуют предварительного объявления или инициализации 
    - Переменная считается объявленной и иницализированной после любого упоминания этой переменной в левом операнде любой операции 
- Запрос может принимать переменные от пользователя 
    - Имена входящих переменных должны соответствовать шаблону `\$[a-zA-Z0-9_-]+`, то есть как и любые другие переменные 
    - Входящие переменные передаются в запрос в формате JSON как объекты, где ключом является название переменной, а значение является содержимым переменной 
- Операции могут использовать конвееры, то есть данные от выполнения одного запроса передаются как входные в следующий запрос 
    - Конвеер обозначается символом "|" между запросами и соответствует шаблону `\s*|\s*` 
    - Запросы в конвеере могут находится как на разных строках, так и на одной 
    - Ответ из левой части конвеерной операции передается в правую часть и заполняет поля аргументов входной функции слева на право 
    - Если количество возвращаемых значение из левой части конвеера превышает количество аргументов правой части, то заполняются только те значения, которые предусмотренны правой частью конвеерной операции 
    - Если возвращаемых значений конвеерной операции недостаточно для заполнения аргументов, то формируется ошибка и выполнение всего запроса прекращается 
    - Недостаток заполнения аргументов правой части конвеерной операции, можно компенсировать непосредственным заполнением аргументов 
    - Полный конвеер может содержать много конвеерных операций, в которых данные передаются от одной операции к другой 
    - Результат выполнения конвеера может быть передан в переменную левого операнда на первой строке конвеера 
- VQL поддерживает операции присваивания, сравнения, логические операции, арифметические операции и строковые конкатенации 
    - Присваивание обозначается символом "=" 
        - Слева от знака присваивания находится принимающая переменная и ничто другое 
            - Если слева от знака присваивания нет переменной, то данные передаются стандартной зарезервированной переменной $result 
            - Если переменная $result использовалась ранее, то данные этой переменной будут перезаписаны 
        - Справа от знака присваивания находится источник даннах 
            - Источником данных может быть переменная 
            - Источником данных может быть пользовательская функция 
            - Источником данных может быть директива или стандартная функция 
            - Источником данных может быть конвеер после выполнения всех его конвеерных операций 
    - Операции сравнения 
        - Больше: ">" 
        - Меньше: "<" 
        - Равно: "==" 
        - Больше или равно: ">=" 
        - Меньше или равно: "<=" 
    - Логические операции 
        - Логическое И: "&&" 
        - Логическое ИЛИ: "||" 
        - Логическое НЕ: "!" 
    - Арифметические операции поддерживают только целочисленные вычисления 
        - Сложение: "+" 
        - Вычитание: "-" 
        - Умножение: "*" 
        - Деление без остатка: "/" 
        - Остаток от деления: "%" 
        - Возведение в степень: "^" 
    - Строковая конкатенация 
        - Сложение строк: "." 
- Операция может начинаться с любого количества символов пробела или табуляции, эти символы не несут никакого лексического значения и нужны только для красивого оформления тела запроса 
- Между операндами в операции может быть любое количество символов пробела или табуляции 
- Любой незадекларированный набор символов является атомом, то есть его имя в исходном тексте запроса и его значение равны и являются константой 
    - Любое число само по себе является атомом, например, запись 123456789 является и именем числа и его значением 
    - Любой набор символов без пробела и без табуляции является строковой константой и атомом 
    - Для использования строки с пробелами и другими специальными символами внутри, нужно изспользовать обрамляющие кавычки (двойные или одинарные) 
- Пользовательскии и стандартные функции, а также директивы возвращают данные как результат операции.
- Процедуры (функции не возвращающие данных) не имеют в смысла в VQL и не используются 
- Если функция или деректива вызываются без присваивания значения переменной, то результат помещается в служебную переменную $result
- Сигнатура функций: 
    - func название_функции(аргумент1, аргумент2, другие_аргументы) возвращаемое_значение {} 
    - func название_функции(аргумент1, аргумент2, другие_аргументы) (значение1, значение2, ...) {} 


### Типы данных

VQL не требует типизации переменных, либо типизации данных, но сами типы данных существуют в самой минималистичной форме 

|Тип|Обозначение|Описание|
|:-|:-|:-|
|atom|[a-zA-Z][a-zA-Z0-9_-]+|Любое обозначение являющееся как собственным именем, так и собственным значением|
|boolean|true false|Элементы логики, являются разновидностью атомов|
|number|[0-9]+|Число, разновидность атома являющееся как собственным именем, так и собственным значением|
|error|[0-9]+|Специальный тип для хранения кода ошибки в виде числа, может трактоватся как число и использоваться в арифметических операциях|
|string|""|Набор любых символов, которые могут иметь атомарный вид, либо могут быть заключены в кавычки (одинарные или двойные) если требуется использовать в значении специальные символы|
|array|[]|Массив значений|
|object|{}|Объект, ассоциативный массив, структура, то есть любая форма данных, предполагающая соотвтствие имя-значение (ключ-значение)|

*Важно:* Переменные и их внутреннее содержимое должны быть совместимы с форматом JSON (для максимальной совместимости с другими языками). 


### Директивы и зарезервированные слова 

|Директива|Аргументы|Описание|
|:-|:-|:-|
|func|сигнатура|Объявление функции|
|return|данные|Прерывает выполнение функции и возвращает данные. По-умолчанию, при пустых параметрах, данные равны пустой строке, пустому массиву, пустому объекту, false или 0|
|store|имя ранее объявленной функции|Записывает функцию в текущую базу данных|
|forget|имя функции уже сохраненной в БД|Удаляет из текущей базы данных функцию|
|for _conditions_ {}|инициализация, условие, операторы|Циклическая конструкция, для многократного повторения каких-либо операций|
|continue||Прекращение текущей итерации цикла и переход к следующей итерации|
|break||Завершение цикла|
|if _condition_ {} elseif _condition_ {} else {}|логические операции|Условное выполнение кода|
|where _condition_ |логические операции|Выборка по условию, возвращает массив _id, соответствующих заданным условиям|
|where _condition_ limit _start_, _offset_ |логические операции и числовые ограничения|Выборка по условию, возвращает массив _id, соответствующих заданным условиям и ограничение по длине выборки|
|response|переменная с данными|Прерывает выполнение запроса и отправляет клиенту объект возврата соответствующий конкретной СУБД|


### Стандартные функции 

#### GPF - функции общего назначения (General Purpose Functions)

|Название|Аргументы|Возвращаемое значение|Описание|
|:-|:-|:-|:-|
|len|любой тип|длина сущности|Возвращает длину сущности (для чисел возвращает количество цифр в числе)|


#### DDL — язык определения данных (Data Definition Language) 

|Название|Аргументы|Возвращаемое значение|Описание|
|:-|:-|:-|:-|
|create-db|_имя_ _string_|пустая строка и стандартные реквизиты выполнения|Создание базы данных|
|create-table|_имя_ _string_, _названия_полей_ [array]|пустая строка и стандартные реквизиты выполнения|Создание таблицы, перед выполнением обязательно нужно выполнить use(dbName)|


#### DML — язык изменения данных (Data Manipulation Language) 


#### DCL — язык управления данными (Data Control Language) 

___

##### func auth( \$login string, \$password string ) string
***Название:*** auth 
***Аргументы:*** логин и пароль 
***Возвращаемое значение:*** тикет 
***Описание:*** Производит авторизацию пользователя, принимает логин и нехешированный пароль, а возвращает строку с тикетом, для дальнейших работ с СУБД 
***Пример:***
```vql
    $tiket = auth("root", "toor")
```

```vql
    $tiket = auth($1, $2)
```
___

##### func auth-secure( \$login string, \$hash string ) string
***Название:*** auth-secure 
***Аргументы:*** логин и хэш пароля 
***Возвращаемое значение:*** тикет 
***Описание:*** Производит авторизацию пользователя, принимает логин и хэш пароля, а возвращает строку с тикетом, для дальнейших работ с СУБД 
***Пример:***
```vql
    $tiket = auth-secure("root", "1b4f0e9851971998e732078544c96b36c3d01cedf7caa332359d6f1d83567014")
```
```vql
    $tiket = auth-secure($1, $2)
```
___

##### func auth-new( \$login string, \$password string ) boolean, error
***Название:*** auth-new 
***Аргументы:*** логин и пароль
***Возвращаемое значение:*** признак выполнения операции и код ошибки 
***Описание:*** Добляет нового пользователя, без привилегий. Принимает логин и нехешированный пароль, а возвращает формальные признаки выполнения
***Пример:***
```vql
    $ok, $err = auth-new("test1", "test1")
```
```vql
    $ok, $err = auth-new($1, $2)
```
___

##### func auth-remove( \$login string ) boolean, error
***Название:*** auth-remove 
***Аргументы:*** логин 
***Возвращаемое значение:*** признак выполнения операции и код ошибки 
***Описание:*** Удаляет пользователя. Принимает логин, а возвращает формальные признаки операции. 
***Пример:***
```vql
    $ok, $err = auth-remove("test1")
```
```vql
    $ok, $err = auth-remove($1)
```
___

##### func auth-change( \$login string, \$password string, \$roles []string ) boolean, error
***Название:*** auth-change 
***Аргументы:*** логин, пароль, список новых ролей
***Возвращаемое значение:*** признак выполнения операции и код ошибки 
***Описание:*** Меняет пароль для пользователя и его роль в рамках СУБД. Принимает логин, новый нехешированный пароль и список ролей, а возвращает формальные признаки выполнения.
***Пример:***
```vql
    $ok, $err = auth-change("test1", "test1", ["ADMIN", "ENGINEER", "MANAGER", "USER"])
```
```vql
    $ok, $err = auth-change(test1, test1, [ADMIN, ENGINEER, MANAGER, USER])
```
```vql
    $ok, $err = auth-change($1, $2, $3)
```
___

##### func use( \$db string ) boolean, error
***Название:*** use 
***Аргументы:*** имя БД
***Возвращаемое значение:*** признак выполнения операции и код ошибки 
***Описание:*** Устанавливает текущую рабочую базу данны, которая будет использоваться остальными командами.
***Пример:***
```vql
    $ok, $err = use("dbName")
```
```vql
    $ok, $err = use($1)
```
___

##### func show-dbs() []string, boolean, error
***Название:*** show-dbs 
***Аргументы:*** 
***Возвращаемое значение:*** массив строк, признак выполнения операции и код ошибки 
***Описание:*** Возвращает названия всех баз данных, обслуживаемых данным экземпляром СУБД.
***Пример:***
```vql
    $dbs, $ok, $err = show-dbs()
```
```vql
    $dbs, $ok, $err = show-dbs()
```
___

##### func show-tables() []string, boolean, error
***Название:*** show-tables 
***Аргументы:*** 
***Возвращаемое значение:*** массив строк, признак выполнения операции и код ошибки 
***Описание:*** Возвращает названия всех таблиц текущей базы данных.
***Пример:***
```vql
    $dbs, $ok, $err = show-tables()
```
```vql
    $dbs, $ok, $err = show-tables()
```
___

##### func describe( \$table string ) []string, boolean, error
***Название:*** describe 
***Аргументы:*** имя таблицы 
***Возвращаемое значение:*** массив строк, признак выполнения операции и код ошибки 
***Описание:*** Возвращает массив строк, где каждая строка является названием столбцов. 
***Пример:***
```vql
    $columns, $ok, $err = describe("users")
```
```vql
    $columns, $ok, $err = describe($1)
```
___

##### func explain( \$table string ) []{}, boolean, error
***Название:*** explain 
***Аргументы:*** имя таблицы 
***Возвращаемое значение:*** массив объектов, признак выполнения операции и код ошибки 
***Описание:*** Возвращает массив объектов, где каждый объект (элемент массива) является полным описанием свойств столбца со спецификой конкретной СУБД. 
***Пример:***
```vql
    $columns, $ok, $err = explain("users")
```
```vql
    $columns, $ok, $err = explain($1)
```
___

##### func grant( \$dbs []string, \$users []string, \$privileges []string ) boolean, error
***Название:*** grant 
***Аргументы:*** список БД, список пользователей, список привилегий
***Возвращаемое значение:***  признак выполнения операции и код ошибки 
***Описание:*** Принимает три массива строк с названиями баз данных, именами пользователей и названиями привилегий. Затем устанавливает указанные привилеги для пользоваетелей в каждой базе данных. Возвращает признак успешности и код ошибки. 
***Пример:***
```vql
    $ok, $err = grant(["dbName1", "dbName2"], ["test1", "test2"], ["select", "insert", "update", "delete"])
```
```vql
    $ok, $err = grant($dbs, $users, $privs)
```
___

##### func revoke( \$dbs []string, \$users []string, \$privileges []string ) boolean, error
***Название:*** revoke 
***Аргументы:*** список БД, список пользователей, список привилегий
***Возвращаемое значение:***  признак выполнения операции и код ошибки 
***Описание:*** Принимает три массива строк с названиями баз данных, именами пользователей и названиями привилегий. Затем удаляет указанные привилеги для пользоваетелей в каждой базе данных. Возвращает признак успешности и код ошибки. 
***Пример:***
```vql
    $ok, $err = revoke(["dbName1", "dbName2"], ["test1", "test2"], ["select", "insert", "update", "delete"])
```
```vql
    $ok, $err = revoke($dbs, $users, $privs)
```
___


## Старое как в SQL 

### DDL — язык определения данных (Data Definition Language) 

CREATE	Создает новую таблицу, представление таблицы или другой объект в БД
ALTER	Модифицирует существующий в БД объект, такой как таблица
DROP	Удаляет существующую таблицу, представление таблицы или другой объект в БД


### DML — язык изменения данных (Data Manipulation Language) 

SELECT	Извлекает записи из одной или нескольких таблиц
INSERT	Создает записи
UPDATE	Модифицирует записи
DELETE	Удаляет записи

