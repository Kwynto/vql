# VQL
Это описание обычного языка запросов (VQL) для систем управления базами данных (СУБД).  

***Информация:*** 
VQL - это простой императивный язык для работы с базами данных, свободный от излишеств и помогающий создавать простые, понятные и эффективные запросы к СУБД.  

***Ревизия:*** 
VQL-24:1  

**_Этот репозиторий находится на этапе разработки_**  


## Список терминов: 
|Термин|Описание|
|:-|:-|
|БД|база данных|
|Таблица|двумерных массив, является организационной единицей и реальным хранилищем информации внутри баз данных|
|Запись|строка двумерного массива (таблицы) в котором хранятся данные|
|Ячейка|элемент записи|
|Столбец|совокупность всех ячеек находящихся в одной позиции во всех записях|
|СУБД|система управления базами данных|


## VQL позволяет:

- создавать, удалять и изменять БД и таблицы 
- описывать структуру данных 
- определять данные в БД и управлять ими 
- получать доступ к данным в СУБД 
- устанавливать разрешения на доступ к данным и на манипулирование данными 


## Основные особенности.

- База данных -- это организованная коллекция данных, предназначенная для хранения информации. 
- Коллекции данных можно представлять как двумерные массивы или таблицы. 
- Строка таблицы может называться "запись". 
- Запись состоит из ячеек, которые в контексте таблицы формируют столбцы. 
- Столбцы должны иметь имена и определяют имена для ячеек в записях. 
- Имена БД, таблиц и столбцов (ячеек) должны соответствовать формату `^[a-zA-Z][a-zA-Z0-9_-]*`
- Записи могут иметь дополнительные служебные ячейки, имена которых должны начинаться с символа подчеркивания "_", то есть соответствовать формату  `^_[a-zA-Z0-9_-]+`
- Каждая запись в рамках таблицы должна иметь уникальный идентификатор "_id". 
- Идентификатор записи является уникальным и при удалении записи этот идентификатор не может быть использован повторно для другой записи. 
- Идентификатор записи НЕ является порядковым индексом в таблице. 
- Идентификатор записи может быть сгенерирован криптографическим методом, либо может быть простым инкрементным идентификатором. 
- Ячейки имена которых имеют в своем составе постфикс "_id", являются ячейками для связи таблиц, где левая часть имени (до "_id"), является названием таблицы. 
- Ячейки не имеют типа, так как данные в ячейках это просто набор байт, и данные в ячейкам могут интерпретироваться как строки, которые можно преобразовывать в любой тип на стороне клиентского ПО, или в скрипте пользовательского запроса. 
- Результаты выборок данных желательно представлять в формате JSON (для максимальной совместимости с другими языками). 


## Язык запросов 

### Базовые концепции

- Запрос представляет собой сценарий обращений к СУБД (программу) 
- Запрос состоит из логических блоков, называемых операциями 
- Операция может состоять из одного или нескольких операндов 
- Каждая операция пишется на отдельно строке без конечных символов, либо с разделителем "\n" в конце каждой операции 
- Правильным оформлением запроса является только оформление в соответствии с принципом 1TBS 
- Выполнение запроса
    - Запрос не имеет точки входа и началом выполнения запроса является первая строка запроса 
    - Каждая операция в запросе выполняется последовательно 
    - Объявления и описания пользовательских функций происходит прямо в теле запроса 
    - Функция должна быть объявлена и описана до её вызова 
    - Функция после объявления может быть сохранена в базу данных для повторного использования при помощи директивы store funcName 
    - Функция может быть удалена из БД директивой forget funcName 
    - Каждая база данных имеет свой набор сохраненных функций 
    - Если при сохранении новой функции имя функции уже занято, то старая функция удаляется из БД, а новая записывается 
    - Имена функций должны соответствовать шаблону `[a-zA-Z][a-zA-Z0-9_-]+` 
- Блок операций обозначается символами "{" и "}", то есть так обозначается начало и конец блока операций 
    - Блоком операций является тело описания функции 
    - Блоком операций является тело цикла 
    - Блок операций может быть объявлен произвольно в любом месте сценария запроса, формируя анонимную функцию 
        - Анонимная функция может использоваться как правый операнд и возвращать значение директивой return 
        - Анонимная функция может возвращать значение и записывать результат выполнения в переменную левого операнда, но её внутренний код не может быть присвоен переменной для дальнейшего вызова 
- VQL предполагает использование переменных, которые должны начинаться с символа $ и соответствовать шаблону `\$[a-zA-Z0-9_-]+` 
    - Переменные предназначены для временного хранения данных во время выполнения запроса 
    - Переменные не требуют предварительного объявления или инициализации 
    - Переменная считается объявленной и инициализированной после любого упоминания этой переменной в левом операнде любой операции 
- Запрос может принимать переменные от пользователя 
    - Имена входящих переменных должны соответствовать шаблону `\$[a-zA-Z0-9_-]+`, то есть как и любые другие переменные 
    - Входящие переменные передаются в запрос в формате JSON как объекты, где ключом является название переменной, а значение является содержимым переменной 
- Операции могут использовать конвейеры, то есть данные от выполнения одного запроса передаются как входные в следующий запрос 
    - Конвейер обозначается символом "|" между запросами и соответствует шаблону `\s*|\s*` 
    - Запросы в конвейере могут находится как на разных строках, так и на одной 
    - Ответ из левой части конвейерной операции передается в правую часть и заполняет поля аргументов входной функции слева на право 
    - Если количество возвращаемых значение из левой части конвейера превышает количество аргументов правой части, то заполняются только те значения, которые предусмотрены правой частью конвейерной операции 
    - Если возвращаемых значений конвейерной операции недостаточно для заполнения аргументов, то формируется ошибка и выполнение всего запроса прекращается 
    - Недостаток заполнения аргументов правой части конвейерной операции, можно компенсировать непосредственным заполнением аргументов 
    - Полный конвейер может содержать много конвейерных операций, в которых данные передаются от одной операции к другой 
    - Результат выполнения конвейера может быть передан в переменную левого операнда на первой строке конвейера 
- VQL поддерживает операции присваивания, сравнения, логические операции, арифметические операции и строковые конкатенации 
    - Присваивание обозначается символом "=" 
        - Слева от знака присваивания находится принимающая переменная и ничто другое 
            - Если слева от знака присваивания нет переменной, то данные передаются стандартной зарезервированной переменной $result 
            - Если переменная $result использовалась ранее, то данные этой переменной будут перезаписаны 
        - Справа от знака присваивания находится источник данных 
            - Источником данных может быть переменная 
            - Источником данных может быть пользовательская функция 
            - Источником данных может быть директива или стандартная функция 
            - Источником данных может быть конвейер после выполнения всех его конвейерных операций 
    - Операции сравнения 
        - Больше: ">" 
        - Меньше: "<" 
        - Равно: "==" 
        - Больше или равно: ">=" 
        - Меньше или равно: "<=" 
    - Логические операции 
        - Логическое И: "&&" 
        - Логическое ИЛИ: "||" 
        - Логическое НЕ: "!" 
    - Арифметические операции поддерживают только целочисленные вычисления 
        - Сложение: "+" 
        - Вычитание: "-" 
        - Умножение: "*" 
        - Деление без остатка: "/" 
        - Остаток от деления: "%" 
        - Возведение в степень: "^" 
        - Увеличение на единицу: "++" 
        - Уменьшение на единицу: "--" 
    - Строковая конкатенация 
        - Сложение строк: "." 
- Операция может начинаться с любого количества символов пробела или табуляции, эти символы не несут никакого лексического значения и нужны только для красивого оформления тела запроса 
- Между операндами в операции может быть любое количество символов пробела или табуляции 
- Любой не декларированный набор символов является атомом, то есть его имя в исходном тексте запроса и его значение равны и являются константой 
    - Любое число само по себе является атомом, например, запись 123456789 является и именем числа и его значением 
    - Любой набор символов без пробела и без табуляции является строковой константой и атомом 
    - Для использования строки с пробелами и другими специальными символами внутри, нужно использовать обрамляющие кавычки (двойные или одинарные) 
- Пользовательские и стандартные функции, а также директивы возвращают данные как результат операции.
- Процедуры (функции не возвращающие данных) не имеют смысла в VQL и не используются 
- Если функция или директива вызываются без присваивания значения переменной, то результат помещается в служебную переменную $result 
- Сигнатура функций: 
    - func название_функции(аргумент1, аргумент2, другие_аргументы) возвращаемое_значение {} 
    - func название_функции(аргумент1, аргумент2, другие_аргументы) (значение1, значение2, ...) {} 
- В запросе могут быть записаны не операционные данные, называемые комментариями. Начало комментария обозначается комбинацией символов "//" и продолжается до конца строки. 


### Типы данных

VQL не требует типизации переменных, либо типизации данных, но сами типы данных существуют в самой минималистичной форме. 

|Тип|Обозначение|Описание|
|:-|:-|:-|
|any||Любой тип|
|atom|[a-zA-Z][a-zA-Z0-9_-]+|Любое обозначение являющееся как собственным именем, так и собственным значением|
|boolean|true false|Элементы логики, являются разновидностью атомов|
|number|[0-9]+|Число, разновидность атома являющееся как собственным именем, так и собственным значением|
|error|[0-9]+|Специальный тип для хранения кода ошибки в виде числа, может трактоваться как число и использоваться в арифметических операциях|
|string|""|Набор любых символов, которые могут иметь атомарный вид, либо могут быть заключены в кавычки (одинарные или двойные) если требуется использовать в значении специальные символы|
|array|[]|Массив значений|
|object|{}|Объект, ассоциативный массив, структура, то есть любая форма данных, предполагающая соответствие имя-значение (ключ-значение)|

*Важно:* Переменные и их внутреннее содержимое должны быть совместимы с форматом JSON (для максимальной совместимости с другими языками). 


### Директивы и зарезервированные слова 

___

***Директива:*** func  
***Аргументы:*** сигнатура  
***Описание:*** Объявление функции  
***Пример:***  
```vql
    func ifNotExists($db string, $table, $columns []string) error {
        $err = create-db($db)
        if $err != 0 {
            return $err
        }

        use($db, "")

        $err = create-table($table,  $columns)
        if $err != 0 {
            return $err
        }

        use($db, $table)

        return 0
    }
    
    $err = ifNotExists($db, $table, ["name", "age", "sex", "prof", "comment"])
```
___

***Директива:*** return  
***Аргументы:*** данные  
***Описание:*** Прерывает выполнение функции и возвращает данные. По-умолчанию, при пустых параметрах, данные равны пустой строке, пустому массиву, пустому объекту, false или 0.  
***Пример:***  
```vql
    func someFunc() boolean {
        return true
    }

    $ok = someFunc()
```
___

***Директива:*** store  
***Аргументы:*** имя ранее объявленной функции  
***Описание:*** Записывает функцию в текущую базу данных, но не запускает её.  
***Пример:***  
```vql
    func ifNotExists($db string, $table, $columns []string) error {
        $err = create-db($db)
        if $err != 0 {
            return $err
        }
        
        use($db, "")

        $err = create-table($table,  $columns)
        if $err != 0 {
            return $err
        }

        use($db, $table)

        return 0
    }

    store ifNotExists
```
___

***Директива:*** forget  
***Аргументы:*** имя функции уже сохраненной в БД  
***Описание:*** Удаляет из текущей базы данных функцию.  
***Пример:***  
```vql
    forget ifNotExists
```
___

***Директива:*** functionality  
***Возвращаемое значение:*** строка с текстом всех сохраненных функций  
***Описание:*** Возвращает полный текст функций, сохраненных в БД.  
***Пример:***  
```vql
    $sourceCode = functionality
```
```vql
    functionality
    $sourceCode = $result
```
___

***Директива:*** for _conditions_ {}  
***Аргументы:*** инициализация, условие, операторы  
***Описание:*** Циклическая конструкция, для многократного повторения каких-либо операций.  
***Пример:***  
```vql
    for $i = 0, $i < 10, $i++ {
        // some kind of operation 
        log("INFO", "i = ".$i)
    }
```
___

***Директива:*** continue  
***Описание:*** Прекращение текущей итерации цикла и переход к следующей итерации.  
***Пример:***  
```vql
    for $i = 0, $i < 10, $i++ {
        // some kind of operation
        if $i < 6 {
            continue
        }

        log("INFO", "i = ".$i)
    }
```
___

***Директива:*** break  
***Описание:*** Завершение цикла.  
***Пример:***  
```vql
    for $i = 0, $i < 10, $i++ {
        // some kind of operation
        if $i > 6 {
            break
        }
        
        log("INFO", "i = ".$i)
    }
```
___

***Директива:*** if _condition_ {} elseif _condition_ {} else {}  
***Аргументы:*** логические операции  
***Описание:*** Условное выполнение кода.  
***Пример:***  
```vql
    if $1 == 0 {
        log("INFO", "null")
    } elseif $1 > 0 {
        log("INFO", "more")
    } else {
        log("INFO", "less")
    }
```
___

***Директива:*** where _condition_ < orderby _colName_ asc|desc > < limit _start_, _offset_ >  
***Аргументы:*** логические операции  
***Возвращаемое значение:*** массив идентификаторов _id  
***Описание:*** Выборка по условию, возвращает массив _id, соответствующих заданным условиям. Выборка осуществляется из текущей БД и таблицы установленные командой use(). Левый операнд в условии всегда название ячейки в записи таблицы, а правый операнд всегда значение ячейки записи для выполнения условия.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" 
```
```vql
    use(shop, customers)
    $idsCustomers = where age >= $1 AND city == $2 
```
___

***Директива:*** < ... > limit _start_, _offset_  
***Аргументы:*** числовые ограничения  
***Описание:*** Это дополнительная субдиректива для директивы where. Ограничители являются начальным индексом и смещением в массиве после выборки по условию для формирования конечного результирующего массива идентификаторов.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" limit 0, 100
```
```vql
    use(shop, customers)
    $idsCustomers = where age >= $1 AND city == $2 limit 100, 100
```
___

***Директива:*** < ... > orderby _colName_ asc|desc  
***Аргументы:*** имя столбца для сортировки  
***Описание:*** Это дополнительная субдиректива для директивы where. Указание порядка сортировки и имя столбца как основание для сортировки результирующего набора данных. Сортировка осуществляется в прямом и обратном порядке. По-умолчанию, сортировка проводится в прямом порядке (asc).  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" orderby "name" asc
```
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" orderby "_id" desc
```
```vql
    use(shop, customers)
    $idsCustomers = where age >= $1 AND city == $2 orderby age asc limit 0, 100
```
___

***Директива:*** transaction { _operations_ rollback _operations_ commit }  
***Аргументы:*** операции  
***Описание:*** Атомарное выполнение нескольких связанных операций. Начинает транзакцию, отменяет операции и подтверждает выполнение операций. Субдирективы rollback и commit завершают транзакцию.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow"

    transaction {
        use("shop", "sales")
        $idsSales = where "customers_id" == $idsCustomers
        $err = update( {"geosale": $1}, $idsSales )
        if $err != 0 {
            rollback
        }

        use("shop", "customers")
        $data, $err = select(["sumsale"], $idsCustomers)
        if $err != 0 {
            rollback
        }

        $l1 = len($data)
        for $i = 0, $i < $l1, $i++ {
            $record = $data[$i]
            $id = $record["_id"]
            $value = $record["sumsale"] + $1
            $err = update( {"sumsale": $value}, [$id] )
            if $err != 0 {
                rollback
            }
        }

        log("INFO", "Transaction is complete.")
        commit
    }
```
___

***Директива:*** response  
***Аргументы:*** переменная с данными  
***Описание:*** Прерывает выполнение запроса и отправляет клиенту объект возврата соответствующий конкретной СУБД.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" limit 0, 100

    $newTicket, $_ = verification()

    $res = ""
    if len($newTicket) == 0 {
        $res = {"status": "ok", "data": $idsCustomers}
    } else {
        $res = {"status": "ok", "ticket": $newTicket, "data": $idsCustomers}
    }

    response $res
```
___


### Стандартные функции 

#### GPF - функции общего назначения (General Purpose Functions)

___

##### func len( \$v any ) number
***Название:*** len  
***Аргументы:*** одна переменная любого типа  
***Возвращаемое значение:*** число (длина сущности)  
***Описание:*** Производит определение типа переменной и возвращает длину сущности (для чисел возвращает количество цифр в числе)  
***Пример:***  
```vql
    $lengthStr = len("any string")
```

```vql
    $lengthStr = len($1)
```
___

##### func verification() string, error 
***Название:*** verification  
***Аргументы:***  
***Возвращаемое значение:*** тикет и код ошибки  
***Описание:*** Проверяет актуальность тикета и возвращает новый тикет при необходимости или старый тикет. Следует заметить, что запрос с неверным тикетом вообще не должен начинать выполнение, а возврат нового тикета нужен только для форматирования правильного ответа.  
***Пример:***  
```vql
    $newTicket, $_ = verification()
```
___

##### func log($level string, $v any) boolean
***Название:*** log  
***Аргументы:*** уровень логирования и любое значение  
***Возвращаемое значение:*** признак выполнения операции  
***Описание:*** Производит запись в лог БД.  
***Пример:***  
```vql
    $ok = log("INFO", "This is information.")
```
```vql
    log("INFO", "This is information.")
```
___

##### func version() string, string 
***Название:*** version  
***Возвращаемое значение:*** версия языка и версия СУБД  
***Описание:*** Возвращает две строки с версией VQL и версией СУБД.  
***Пример:***  
```vql
    $vql, $dbms = version()
    log("INFO", "VQL  version: ".$vql)
    log("INFO", "DBMS version: ".$dbms)
```
___


#### DDF — функции определения данных (Data Definition Functions) 

___

##### func create-db( \$db string ) error 
***Название:*** create-db  
***Аргументы:*** имя базы данных  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Создание базы данных с заданным именем.  
***Пример:***  
```vql
    $err = create-db("dbName")
```
```vql
    $err = create-db($1)
```
___

##### func create-table( \$table string, \$columns []string) error 
***Название:*** create-table  
***Аргументы:*** имя таблицы и массив строк с названиями столбцов  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Создание таблицы с заданным именем и с набором заданных столбцов. Перед выполнением обязательно нужно выполнить use(dbName, "").  
***Пример:***  
```vql
    use("dbName", "")
    $err = create-table("tableName", ["name", "age", "sex", "prof", "comment"])
```
```vql
    use($1, "")
    $err = create-table($2, $3)
```
___

##### func alter-db-rename( \$oldName string, \$newName string ) error 
***Название:*** alter-db-rename  
***Аргументы:*** старое и новое имя базы данных  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Изменение имени базы дынных.  
***Пример:***  
```vql
    $err = alter-db-rename("dbName", "newDbName")
```
```vql
    $err = alter-db-rename($1, $2)
```
___

##### func alter-table-rename( \$oldName string, \$newName string ) error 
***Название:*** alter-table-rename  
***Аргументы:*** старое и новое имя таблицы  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Изменение имени таблицы в базе дынных.  
***Пример:***  
```vql
    use("dbName", "")
    $err = alter-table-rename("tableName", "newTableName")
```
```vql
    use("dbName", "")
    $err = alter-table-rename($1, $2)
```
___

##### func alter-table-add( \$colName string, \$sett object ) error 
***Название:*** alter-table-add  
***Аргументы:*** имя нового столбца в таблице и его характеристики  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Добавление нового столбца в текущую рабочую таблицу. Характеристики столбца могут быть пустым объектом, либо заполненный различным способом зависящим от возможностей СУБД.  
***Пример:***  
```vql
    use("shop", "customers")
    $err = alter-table-add("city", {})
```
```vql
    use("shop", "customers")
    $err = alter-table-add("city", {"Default": "Moscow", "NotNull": true, "Unique": false} )
```
```vql
    use($1, $2)
    $err = alter-table-add($3, $4)
```
___

##### func alter-table-drop( \$colName string ) error 
***Название:*** alter-table-drop  
***Аргументы:*** имя удаляемого столбца в таблице  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Удаление столбца из текущей рабочей таблицы.  
***Пример:***  
```vql
    use("shop", "customers")
    $err = alter-table-drop("city")
```
```vql
    use($1, $2)
    $err = alter-table-drop($3)
```
___

##### func alter-table-modify( \$colName string, \$sett object ) error 
***Название:*** alter-table-modify  
***Аргументы:*** имя изменяемого столбца в таблице и набор его характеристик  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Изменение набора характеристик столбца из текущей рабочей таблицы.  
***Пример:***  
```vql
    use("shop", "customers")
    $err = alter-table-modify("city", {"Default": "Moscow", "NotNull": true, "Unique": false} )
```
```vql
    use($1, $2)
    $err = alter-table-modify($3, $4)
```
___

##### func alter-table-modify-rename( \$colOldName string, \$colNewName string ) error 
***Название:*** alter-table-modify-rename  
***Аргументы:*** старое и новое имя столбца  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Переименование столбца из текущей рабочей таблицы.  
***Пример:***  
```vql
    use("manage", "users")
    $err = alter-table-modify-rename("login", "username" )
```
```vql
    use($1, $2)
    $err = alter-table-modify-rename($3, $4)
```
___

##### func drop-db( \$db string ) error 
***Название:*** drop-db  
***Аргументы:*** имя базы данных  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Удаление базы данных с заданным именем.  
***Пример:***  
```vql
    $err = drop-db("dbName")
```
```vql
    $err = drop-db($1)
```
___

##### func drop-table( \$table string ) error 
***Название:*** drop-table  
***Аргументы:*** имя таблицы  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Удаление таблицы с заданным именем из текущей рабочей БД.  
***Пример:***  
```vql
    use("dbName", "")
    $err = drop-table("tableName")
```
```vql
    use($1, "")
    $err = drop-table($2)
```
___


#### DMF — функции изменения данных (Data Manipulation Functions) 

___

##### func select( \$fields []string, $where []number) []{}, error 
***Название:*** select  
***Аргументы:*** массив названий полей для выборки и массив идентификаторов _id  
***Возвращаемое значение:*** массив объектов и код ошибки  
***Описание:*** Извлекает записи из текущей рабочей таблицы. Получает на входе массив строк с названиями извлекаемых ячеек и массив уникальных идентификаторов записей. Ответ представляет собой массив записей. Каждая запись это объект в котором именем поля является название ячейки записи из рабочей таблицы, а значением поля является извлекаемое значение. Если массив полей пустой, то выбираются все поля. Если массив идентификаторов пустой, то выборка охватывает всю таблицу.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "age" >= 18 AND "city" == "Moscow" limit 0, 100

    $data, $err = select(["login", "name", "surname", "age", "city"], $idsCustomers)
```
```vql
    use($1, $2)
    $idsCustomers = where "age" >= $3 AND "city" == $4 limit 0, 100

    $data, $err = select(["login", "name", "surname", "age", "city"], $idsCustomers)
```
```vql
    use($1, $2)
    $idsCustomers = where "age" >= $3 AND "city" == $4 limit 0, 100

    $data, $err = select([], $idsCustomers)
```
```vql
    func selectAll( $nameDb string, $nameTab string) []{}, error {
        use($nameDb, $nameTab)
        $inData, $err = select([], [])
        return $inData, $err
    }

    store selectAll
```
___

##### func insert( \$records []{}) []number, error 
***Название:*** insert  
***Аргументы:*** массив объектов для создания новых записей из названий полей и их значений  
***Возвращаемое значение:*** массив уникальных идентификаторов созданных записей и код ошибки  
***Описание:*** Создает одну или несколько записей в текущей рабочей таблице. Получает массив объектов из названий полей и их значений, которые нужно вставить в таблицу как новую запись. Ответ представляет собой массив идентификаторов новых записей.  
***Пример:***  
```vql
    use("shop", "customers")
    
    $insId, $err = insert( [{"login": "kwynto", "name": "Constantine", "surname": "Zavezeon", "age": 42, "city": "Kursk"}] )
```
```vql
    use($1, $2)
    $record = [{"login": $3, "name": $4, "surname": $5, "age": $6, "city": $7}]

    $insId, $err = insert($record)
```
```vql
    use($1, $2)
    
    $insId, $err = insert($3)
```
___

##### func update( \$fields {}, \$where []number) error 
***Название:*** update  
***Аргументы:*** объект с названиями полей и новыми значениями, и массив идентификаторов _id изменяемых записей  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Модифицирует записи в текущей рабочей таблице.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "city" == "Nur-Sultan"
    
    $err = update( {"city": "Astana"}, $idsCustomers )
```
```vql
    use($1, $2)
    $idsCustomers = where "city" == $3
    
    $err = update( {"city": $4}, $idsCustomers )
```
```vql
    func renameTheCity( $nameDb string, $nameTab string, $oldNameCity string, $newNameCity string ) error {
        use($nameDb, $nameTab)
        $idsCustomers = where "city" == $oldNameCity
        $err = update( {"city": $newNameCity}, $idsCustomers )
        return $err
    }

    store renameTheCity
```
___

##### func delete( \$where []number) error 
***Название:*** delete  
***Аргументы:*** массив идентификаторов _id удаляемых записей  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Удаляет записи.  
***Пример:***  
```vql
    use("shop", "customers")
    $idsCustomers = where "ban" == true
    
    $err = delete( $idsCustomers )
```
___

##### func truncate() error 
***Название:*** truncate  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Очистка таблицы (удаление всех записей). Не влияет на инкрементные идентификаторы, только удаляет записи с данными.  
***Пример:***  
```vql
    use("shop", "customers")
        
    $err = truncate()
```
___


#### DCF — функции управления данными (Data Control Functions) 

___

##### func auth( \$login string, \$password string ) string
***Название:*** auth  
***Аргументы:*** логин и пароль  
***Возвращаемое значение:*** тикет  
***Описание:*** Производит авторизацию пользователя, принимает логин и нехэшированный пароль, а возвращает строку с тикетом, для дальнейших работ с СУБД  
***Пример:***  
```vql
    $ticket = auth("root", "toor")
```

```vql
    $ticket = auth($1, $2)
```
___

##### func auth-secure( \$login string, \$hash string ) string
***Название:*** auth-secure  
***Аргументы:*** логин и хэш пароля  
***Возвращаемое значение:*** тикет  
***Описание:*** Производит авторизацию пользователя, принимает логин и хэш пароля, а возвращает строку с тикетом, для дальнейших работ с СУБД  
***Пример:***  
```vql
    $ticket = auth-secure("root", "1b4f0e9851971998e732078544c96b36c3d01cedf7caa332359d6f1d83567014")
```
```vql
    $ticket = auth-secure($1, $2)
```
___

##### func auth-new( \$login string, \$password string ) error
***Название:*** auth-new  
***Аргументы:*** логин и пароль  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Добавляет нового пользователя, без привилегий. Принимает логин и нехэшированный пароль, а возвращает формальные признаки выполнения  
***Пример:***  
```vql
    $err = auth-new("test1", "test1")
```
```vql
    $err = auth-new($1, $2)
```
___

##### func auth-remove( \$login string ) error
***Название:*** auth-remove  
***Аргументы:*** логин  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Удаляет пользователя. Принимает логин, а возвращает формальные признаки операции.  
***Пример:***  
```vql
    $err = auth-remove("test1")
```
```vql
    $err = auth-remove($1)
```
___

##### func auth-change( \$login string, \$password string, \$roles []string ) error
***Название:*** auth-change  
***Аргументы:*** логин, пароль, список новых ролей  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Меняет пароль для пользователя и его роль в рамках СУБД. Принимает логин, новый нехэшированный пароль и список ролей, а возвращает формальные признаки выполнения.  
***Пример:***  
```vql
    $err = auth-change("test1", "test1", ["ADMIN", "ENGINEER", "MANAGER", "USER"])
```
```vql
    $err = auth-change(test1, test1, [ADMIN, ENGINEER, MANAGER, USER])
```
```vql
    $err = auth-change($1, $2, $3)
```
___

##### func use( \$db string, \$table string ) error
***Название:*** use  
***Аргументы:*** имя БД и имя таблицы  
***Возвращаемое значение:*** код ошибки  
***Описание:*** Устанавливает текущую рабочую БД и рабочую таблицу, которые будет использоваться остальными командами. Если имя таблицы является пустой строкой, то устанавливается только рабочая БД.  
***Пример:***  
```vql
    $err = use("dbName", "tableName")
```
```vql
    $err = use($1, $2)
```
```vql
    $err = use("dbName", "")
```
___

##### func show-dbs() []string, error
***Название:*** show-dbs  
***Аргументы:***  
***Возвращаемое значение:*** массив строк и код ошибки  
***Описание:*** Возвращает названия всех баз данных, обслуживаемых данным экземпляром СУБД.  
***Пример:***  
```vql
    $dbs, $err = show-dbs()
```
```vql
    $dbs, $err = show-dbs()
```
___

##### func show-tables() []string, error
***Название:*** show-tables  
***Аргументы:***  
***Возвращаемое значение:*** массив строк и код ошибки  
***Описание:*** Возвращает названия всех таблиц текущей базы данных.  
***Пример:***  
```vql
    $dbs, $err = show-tables()
```
```vql
    $dbs, $err = show-tables()
```
___

##### func describe( \$table string ) []string, error
***Название:*** describe  
***Аргументы:*** имя таблицы  
***Возвращаемое значение:*** массив строк и код ошибки  
***Описание:*** Возвращает массив строк, где каждая строка является названием столбцов.  
***Пример:***  
```vql
    $columns, $err = describe("users")
```
```vql
    $columns, $err = describe($1)
```
___

##### func explain( \$table string ) []{}, error
***Название:*** explain  
***Аргументы:*** имя таблицы  
***Возвращаемое значение:*** массив объектов и код ошибки  
***Описание:*** Возвращает массив объектов, где каждый объект (элемент массива) является полным описанием свойств столбца со спецификой конкретной СУБД.  
***Пример:***  
```vql
    $columns, $err = explain("users")
```
```vql
    $columns, $err = explain($1)
```
___

##### func grant( \$dbs []string, \$users []string, \$privileges []string ) error
***Название:*** grant  
***Аргументы:*** список БД, список пользователей, список привилегий  
***Возвращаемое значение:***  код ошибки  
***Описание:*** Принимает три массива строк с названиями баз данных, именами пользователей и названиями привилегий. Затем устанавливает указанные привилегии для пользователей в каждой базе данных. Возвращает код ошибки.  
***Пример:***  
```vql
    $err = grant(["dbName1", "dbName2"], ["test1", "test2"], ["select", "insert", "update", "delete"])
```
```vql
    $err = grant($dbs, $users, $privs)
```
___

##### func revoke( \$dbs []string, \$users []string, \$privileges []string ) error
***Название:*** revoke  
***Аргументы:*** список БД, список пользователей, список привилегий  
***Возвращаемое значение:***  код ошибки  
***Описание:*** Принимает три массива строк с названиями баз данных, именами пользователей и названиями привилегий. Затем удаляет указанные привилегии для пользователей в каждой базе данных. Возвращает код ошибки.  
***Пример:***  
```vql
    $err = revoke(["dbName1", "dbName2"], ["test1", "test2"], ["select", "insert", "update", "delete"])
```
```vql
    $err = revoke($dbs, $users, $privs)
```
___


## Оптимизация запросов

VQL рассчитан на унификацию языка запросов и хранимых процедур.  
Эта особенность языка позволяет разрабатывать программные интерфейсы для взаимодействия с любой конкретной базой данных самым оптимальным способом.  
VQL позволяет разделить ответственности по работе с данными между профессионалами различного уровня и различной компетенции, но при этом не ограничивает моноразработчиков.  


## Благодарности за помощь

*этот раздел пока пуст*


## Об авторе 

Автор проекта Константин Завизион (Kwynto).  
Вы можете связаться с автором по e-mail: kwynto@mail.ru  

